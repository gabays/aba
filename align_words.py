# -*- coding: utf-8 -*-
"""align_words.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aMpHe8n4CmPaf08KtmMg4-M5GpbE-Lhc
"""

"""
install and imports
"""

# !pip install pygit2
import os
from os import listdir
from os.path import isfile, join
from shutil import rmtree
from pygit2 import clone_repository

"""
global settings
"""

# source
repo_url = 'https://github.com/e-ditiones/PARALLEL17.git'
repo_dir = 'PARALLEL17'
src_dir = "PARALLEL17/corpus_tsv"

# destination
dst_dir = "corpus_tsv_aligned"

# write mode
delta_only = True

# scoring table
gap_penalty = -1
match_award = 1
mismatch_penalty = -1

"""
download corpus and set directories
"""

# delete repository directory if needed
# rmtree(repo_dir)

# clone repository
if not os.path.exists(repo_dir):
	clone_repository(repo_url, repo_dir)

# create destination directory
if not os.path.exists(dst_dir):
	os.mkdir(dst_dir)

"""
needleman-wunsch algorithm

source : https://wilkelab.org/classes/SDS348/2018_spring/labs/lab13-solution.html
modified to process word sequences instead of letter sequences
"""

def zeros(rows, cols):
	'''returns a matrix of zeros'''
	res = []
	for x in range(rows):
		res.append([])
		for y in range(cols):
			res[-1].append(0)
	return res

def match_score(a, b):
	if a == b:
		return match_award
	elif a == '-' or b == '-':
		return gap_penalty
	else:
		return mismatch_penalty

# needleman-wunsch
def needleman_wunsch(seq1, seq2): 
	
	# init matrix
	n = len(seq1)
	m = len(seq2)
	score = zeros(m + 1, n + 1)
	
	# fill first col
	for i in range(0, m + 1):
		score[i][0] = gap_penalty * i
	# fill first row
	for j in range(0, n + 1):
		score[0][j] = gap_penalty * j
	
	# fill all cells
	for i in range(1, m + 1):
		for j in range(1, n + 1):
			# compute values from top, left, and top-left diagonal cells
			match = score[i - 1][j - 1] + match_score(seq1[j-1], seq2[i-1])
			delete = score[i - 1][j] + gap_penalty
			insert = score[i][j - 1] + gap_penalty
			# store the max of the three values
			score[i][j] = max(match, delete, insert)
 
	# init traceback
	align1 = []
	align2 = []
	i = m
	j = n

	# traceback
	while i > 0 and j > 0:
		
		# retrieve scores
		score_current = score[i][j]
		score_diagonal = score[i-1][j-1]
		score_up = score[i][j-1]
		score_left = score[i-1][j]
		
		# find the origin cell, store corresponding elements, and advance
		if score_current == score_diagonal + match_score(seq1[j-1], seq2[i-1]):
			# origin is top-left diagonal
			align1.append(seq1[j-1])
			align2.append(seq2[i-1])
			i -= 1
			j -= 1
		elif score_current == score_up + gap_penalty:
			# origin is top
			align1.append(seq1[j-1])
			align2.append('-')
			j -= 1
		elif score_current == score_left + gap_penalty:
			# origin is left
			align1.append('-')
			align2.append(seq2[i-1])
			i -= 1

	# proceed to topmost leftmost cell
	while j > 0:
		align1.append(seq1[j-1])
		align2.append('-')
		j -= 1
	while i > 0:
		align1.append('-')
		align2.append(seq2[i-1])
		i -= 1
	
	# reverse the elements order
	align1 = align1[::-1]
	align2 = align2[::-1]
	
	return(align1, align2)

"""
pre-processing
"""

def preprocess(s):
	s = separate_apostrophe(s)
	s = concatenate_que(s)
	s = remove_punctuation(s)
	s = remove_parentheses(s)
	s = split_sequence(s)
	return s

def separate_apostrophe(s):
	return s.replace('’', '’ ').replace('\'', '\' ')

def concatenate_que(s):
	# lors que/lors qu'
	return s.replace('lors qu', 'lorsqu')

def remove_punctuation(s):
	# warning : creates multiple spaces
	s = s.replace('.', ' ')
	s = s.replace(',', ' ')
	s = s.replace(':', ' ')
	s = s.replace(';', ' ')
	return s
 
def remove_parentheses(s):
	return s.replace('(', ' ').replace(')', ' ')

def split_sequence(s):
	# splits on all spaces
	return s.split()

"""
main
"""

files = [f for f in listdir(src_dir) if isfile(join(src_dir, f))]

for f in files:
	
	# print current file name
	print(f)
	
	# open source and destination files
	srcf = open(src_dir + '/' + f, "r", encoding="utf8")
	dstf = open(dst_dir + '/' + f, "w", encoding = "utf8")

	# process source file lines
	for line in srcf.readlines():
		# split line
		seqs = line.rstrip().split('\t')
		# ignore empty line
		if (len(seqs) < 2):
			continue
		# pre-process sequences
		seq1 = preprocess(seqs[0])
		seq2 = preprocess(seqs[1])
		# align words with needleman-wunsch
		out1, out2 = needleman_wunsch(seq1, seq2)
		
	# write to destination file
		for i in range(len(out1)):
			if (delta_only and out1[i] == out2[i]):
				# if delta only, ignore identical words
				continue
			# write both words
			dstf.write(out1[i] + '\t' + out2[i] + '\n')

	# close files
	dstf.close()
	srcf.close()

